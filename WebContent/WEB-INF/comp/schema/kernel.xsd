<?xml version="1.0" encoding="utf-8" ?>
<xs:schema
	targetNamespace="http://www.simplity.org/schema"
	elementFormDefault="qualified"
	xmlns="http://www.simplity.org/schema"
	xmlns:xs="http://www.w3.org/2001/XMLSchema"
	xmlns:dt="http://www.simplity.org/declaredDataTypes"
>

	<xs:import namespace="http://www.simplity.org/declaredDataTypes"></xs:import>
	<!-- data types are organized in one or more files, but not one per file. 
		hence we have a wrapper element <dataTypes> with another wrapper element 
		called <dataTYpes> for the collection. -->
	<xs:element name="dataTypes">
		<xs:annotation>
			<xs:documentation>
				Define data types that your project require, in
				addition to the ones that are built-in
			</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence
				minOccurs="1"
				maxOccurs="1"
			>
				<xs:element name="components">
					<xs:complexType>
						<xs:choice
							minOccurs="1"
							maxOccurs="unbounded"
						>
							<xs:element
								name="booleanDataType"
								type="Btype" />
							<xs:element
								name="dateDataType"
								type="Dtype" />
							<xs:element
								name="numericDataType"
								type="Ntype" />
							<xs:element
								name="textDataType"
								type="Ttype" />
							<xs:element
								name="clobDataType"
								type="Ctype" />
							<xs:element
								name="blobDataType"
								type="Ctype" />
							<xs:element
								name="timestampDataType"
								type="Ctype"
							>
								<xs:annotation>
									<xs:documentation>There is a predefined type called time-stamp.
										Use that. There is no point defining another one
									</xs:documentation>
								</xs:annotation>
							</xs:element>
						</xs:choice>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
			<xs:attribute
				name="name"
				type="xs:NCName"
				use="required" />
		</xs:complexType>
	</xs:element>
	<xs:attributeGroup name="commonAttributes">
		<xs:attribute
			name="name"
			type="xs:NCName"
			use="required"
		>
			<xs:annotation>
				<xs:documentation>
					Name is to be unique within a project. text20 is
					not a good name. shortDescription is a good name
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="messageName"
			type="xs:string"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>
					What is the message to be used to inform the user
					that the field is in error. While defining this message in
					message.xml note that @1 is for field name, while @2 is for value.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="formatter"
			use="optional"
			type="xs:NCName"
		>
			<xs:annotation>
				<xs:documentation>
					name of function that is used by the client-side
					script for formatting this value
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>

		<xs:attribute
			name="description"
			type="xs:string"
			use="optional" />

		<xs:attribute
			name="sqlType"
			type="xs:string"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation> used for creating script to create table
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="valueList"
			type="xs:string"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation> comma separated list of valid values. Like
					enumeration. eg. 1:first,2:second for integral type, or
					first,second for text type
				</xs:documentation>
			</xs:annotation>

		</xs:attribute>
	</xs:attributeGroup>
	<xs:complexType name="Ttype">
		<xs:attributeGroup ref="commonAttributes" />
		<xs:attribute
			name="regex"
			type="xs:string"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation> regular expression pattern that this value should
					specify. As per Java conventions
				</xs:documentation>
			</xs:annotation>

		</xs:attribute>
		<xs:attribute
			name="minLength"
			type="xs:integer"
			use="optional" />
		<xs:attribute
			name="maxLength"
			type="xs:integer"
			use="required"
		>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="Ctype">
		<xs:attributeGroup ref="commonAttributes" />
	</xs:complexType>

	<xs:complexType name="Ntype">
		<xs:attributeGroup ref="commonAttributes" />
		<xs:attribute
			name="minValue"
			type="xs:long"
			use="optional" />
		<xs:attribute
			name="maxValue"
			type="xs:long"
			use="optional" />
		<xs:attribute
			name="nbrFractionDigits"
			type="xs:integer"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>If this is decimal, number of digits after decimal
					point
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="Dtype">
		<xs:attributeGroup ref="commonAttributes" />
		<xs:attribute
			name="maxDaysIntoPast"
			type="xs:integer"
			use="optional"
		></xs:attribute>
		<xs:attribute
			name="maxDaysIntoFuture"
			type="xs:integer"
			use="optional" />
		<xs:attribute
			name="hasTime"
			type="booleanType"
			use="optional" />
	</xs:complexType>

	<xs:complexType name="Btype">
		<xs:attributeGroup ref="commonAttributes" />
	</xs:complexType>

	<xs:simpleType name="booleanType">
		<xs:restriction base="xs:NCName">
			<xs:enumeration value="true" />
			<xs:enumeration value="false" />
		</xs:restriction>
	</xs:simpleType>

	<!-- messages -->
	<!-- Messages are organized in one or more files as collection. We have 
		designed Messages as an element with a wrapper element <messages> that contains 
		<message> elements -->

	<xs:element name="messages">
		<xs:complexType>
			<xs:sequence
				maxOccurs="1"
				minOccurs="1"
			>
				<xs:element name="components">
					<xs:complexType>
						<xs:sequence
							minOccurs="1"
							maxOccurs="unbounded"
						>
							<xs:element name="message">
								<xs:complexType>
									<xs:attribute
										name="name"
										type="xs:NCName"
										use="required" />
									<xs:attribute
										name="text"
										type="xs:string"
										use="required" />
									<xs:attribute
										name="messageType"
										type="messageType"
										use="required" />
								</xs:complexType>
							</xs:element>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
			<xs:attribute
				name="name"
				type="xs:NCName"
				use="required" />
		</xs:complexType>
	</xs:element>

	<!-- record is generally reverse engineered from db for tables but views 
		may have to be entered manually. In any case, let us have the schema. -->
	<xs:element name="record">
		<xs:complexType>
			<xs:sequence
				maxOccurs="1"
				minOccurs="1"
			>
				<xs:element name="fields">
					<xs:complexType>
						<xs:sequence
							minOccurs="1"
							maxOccurs="unbounded"
						>
							<xs:element name="field">
								<xs:complexType>
									<xs:attribute
										name="name"
										type="xs:NCName"
										use="required" />
									<xs:attribute
										name="label"
										type="xs:string"
										use="optional" />
									<xs:attribute
										name="fieldType"
										use="optional"
									>
										<xs:simpleType>
											<xs:annotation>
												<xs:documentation>defaults to 'data' for storage-record, and
													'view' for views
												</xs:documentation>
											</xs:annotation>
											<xs:restriction base="xs:NCName">
												<xs:enumeration value="data" />
												<xs:enumeration value="primaryKey" />
												<xs:enumeration value="parentKey" />
												<xs:enumeration value="foreignKey" />
												<xs:enumeration value="createdTimeStamp" />
												<xs:enumeration value="modifiedTimeStamp" />
												<xs:enumeration value="createdByUser" />
												<xs:enumeration value="modifiedByUser" />
												<xs:enumeration value="view" />
												<xs:enumeration value="temp" />
												<xs:enumeration value="valueArray" />
												<xs:enumeration value="record" />
												<xs:enumeration value="recordArray" />
											</xs:restriction>
										</xs:simpleType>
									</xs:attribute>
									<xs:attribute
										name="dataType"
										type="dt:declaredDataTypes"
										use="optional" />
									<xs:attribute
										name="columnName"
										type="xs:NCName"
										use="optional" />
									<xs:attribute
										name="isNullable"
										type="xs:boolean"
										use="optional" />
									<xs:attribute
										name="referredRecord"
										type="xs:string"
										use="optional"
									>
										<xs:annotation>
											<xs:documentation>for fields in a view, this attribute
												overrides defaultRefRecord at record level
											</xs:documentation>
										</xs:annotation>
									</xs:attribute>
									<xs:attribute
										name="referredField"
										type="xs:NCName"
										use="optional"
									>
										<xs:annotation>
											<xs:documentation>defaults to name</xs:documentation>
										</xs:annotation>
									</xs:attribute>
									<xs:attribute
										name="valueList"
										type="xs:string"
										use="optional" />
									<xs:attribute
										name="isRequired"
										type="xs:boolean"
										use="optional" />
									<xs:attribute
										name="defaultValue"
										type="xs:string"
										use="optional" />
									<xs:attribute
										name="basedOnField"
										type="xs:NCName"
										use="optional" />
									<xs:attribute
										name="otherField"
										type="xs:NCName"
										use="optional" />
									<xs:attribute
										name="fromField"
										type="xs:NCName"
										use="optional" />
									<xs:attribute
										name="toField"
										type="xs:NCName"
										use="optional" />
									<xs:attribute
										name="messageName"
										type="xs:NCName"
										use="optional" />
									<xs:attribute
										name="description"
										type="xs:string"
										use="optional" />
									<xs:attribute
										name="sqlTypeName"
										type="xs:string"
										use="optional"
									>
										<xs:annotation>
											<xs:documentation>Mandatory if fieldType is one of
												valueArray, record or recordArray. This is the name of the
												data structure defined in the rdbms that this field
												corresponds to
											</xs:documentation>
										</xs:annotation>
									</xs:attribute>

								</xs:complexType>
							</xs:element>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
			<xs:attribute
				name="name"
				type="xs:NCName"
				use="required" />
			<xs:attribute
				name="moduleName"
				type="xs:string"
				use="optional" />
			<xs:attribute
				name="recordType"
				use="optional"
			>
				<xs:simpleType>
					<xs:restriction base="xs:NCName">
						<xs:enumeration value="storage" />
						<xs:enumeration value="view" />
						<xs:enumeration value="structure" />
						<xs:enumeration value="output" />
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute
				name="tableName"
				type="xs:string"
				use="optional" />
			<xs:attribute
				name="keyToBeGenerated"
				type="xs:boolean"
				use="optional" />
			<xs:attribute
				name="sequenceName"
				type="xs:string"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>Ignored for non-oracle db. Defaults to
						tableName_seq if omitted.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="okToSelectAll"
				type="xs:boolean"
				use="optional" />
			<xs:attribute
				name="readOnly"
				type="xs:boolean"
				use="optional" />
			<xs:attribute
				name="childrenToBeSaved"
				type="xs:string"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>Child records that are to be read whenever a row
						from this record is read.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="childrenToBeRead"
				type="xs:string"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>Child records that are to be saved along with
						this record
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="defaultRefRecord"
				type="xs:string"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>Must be provided if this record is a view. This
						is the record that the fields are taken from by default. Fields
						taken from other records will use referredRecord at field level to
						over-ride this
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="listFieldName"
				type="xs:NCName"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>If this record is to be used for listing
						key-value pairs, specify the field name to be used for value. Note
						that key field is always the primary key.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="listGroupKeyName"
				type="xs:NCName"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>If this record is to be used for listing
						key-value pairs, and the table contains list of values across
						groups, like states for all countries, then you need to specify
						the
						field name to be used based on which rows are to be subset. For
						example it would be country-code to get list of states for a given
						country
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="suggestionKeyName"
				type="xs:NCName"
				use="optional" />
			<xs:attribute
				name="suggestionOutputNames"
				type="xs:string"
				use="optional" />
			<xs:attribute
				name="defaultSheetName"
				type="xs:string"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>
						First field is typically displayed and used for
						matching while second one is the key/internal value
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="description"
				type="xs:string"
				use="optional" />
			<xs:attribute name="expectedNbrRows">
				<xs:annotation>
					<xs:documentation>
						This is not the upper limit, but the number for
						which we have to tune the design for. Customers tend to be
						defensive, and give large numbers, but that may result in
						sub-optimal design. It is important to articulate that this number
						will put no restriction on actual number rows
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="schemaName"
				type="xs:string"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>If the underlying table/view is in a schema other
						than the default, use this attribute for on-the-fly services for
						this record to use the right schema. Note that this attribute is
						not used for regular service. You have to use schemaName attribute
						at the service level there
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="useTimestampForConcurrency"
				type="booleanType"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>should we insist that the client returns the last
						time stamp during an update that we match with the current row
						before updating it? This technique allows us to detect whether the
						row was updated after it was sent to client.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="okToCacheList"
				type="booleanType"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>if this table is (almost) static, and the
						vauleList that is delivered on a list request can be cached by the
						agent. Valid only if valueListFieldis set (list_ auto service is
						enabled) if valueListKey is specified, the result will be cached
						by that field. For example, by country-code.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="sqlStructName"
				type="xs:string"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>Name used by the rdbms to define a structure that
						this record corresponds to. Mandatory if this record is used as
						child-record by another field in a complex data structure.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>

	<!-- Sql. -->
	<xs:element name="sql">
		<xs:complexType>
			<xs:all>
				<xs:element
					name="preparedStatement"
					minOccurs="0"
					maxOccurs="1"
				>
					<xs:annotation>
						<xs:documentation>use c-section to avoid xml-escaping issues with
							special characters
						</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element
					name="inputParameters"
					type="sqlParameters"
					minOccurs="0"
					maxOccurs="1" />
				<xs:element
					name="outputParameters"
					type="sqlParameters"
					minOccurs="0"
					maxOccurs="1" />
			</xs:all>
			<xs:attributeGroup ref="sqlAttributes" />
			<xs:attribute
				name="preparedStatement"
				type="xs:string"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>use this if it is simple. else use
						preparedStatement element with c-section to avoid encoding issues
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>

	<!-- Stored procedure -->
	<xs:element name="storedProcedure">
		<xs:complexType>
			<xs:sequence
				minOccurs="0"
				maxOccurs="1"
			>
				<xs:element
					name="parameters"
					minOccurs="0"
					maxOccurs="1"
				>
					<xs:complexType>
						<xs:sequence>
							<xs:element
								name="procedureParameter"
								type="procedureParameter"
								minOccurs="1"
								maxOccurs="unbounded" />
						</xs:sequence>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
			<xs:attribute
				name="name"
				type="xs:NCName"
				use="required" />
			<xs:attribute
				name="moduleName"
				type="xs:string"
				use="optional" />
			<xs:attribute
				name="procedureName"
				type="xs:string"
				use="required"
			>
				<xs:annotation>
					<xs:documentation>name as in the rdbms</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="firstParameterIsForReturnedValue"
				type="booleanType"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>if you use the returned value from the procedure,
						then it should be the first parameter
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="outputRecordNames"
				use="optional"
				type="xs:string"
			>
				<xs:annotation>
					<xs:documentation>If this procedure is returning one or more result
						sets, then use record(s) that match the output fields in each of
						this result set. Also, you can not use outputParameters in this
						case.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>

	<xs:attributeGroup name="sqlAttributes">
		<xs:attribute
			name="name"
			type="xs:NCName"
			use="required" />
		<xs:attribute
			name="moduleName"
			type="xs:string"
			use="optional" />
		<xs:attribute
			name="sqlType"
			type="sqlType"
			use="required" />
		<xs:attribute
			name="description"
			type="xs:string"
			use="optional" />
	</xs:attributeGroup>

	<xs:simpleType name="sqlType">
		<xs:restriction base="xs:NCName">
			<xs:enumeration value="singleSelect" />
			<xs:enumeration value="multiSelect" />
			<xs:enumeration value="update" />
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="sqlParameters">
		<xs:sequence
			minOccurs="1"
			maxOccurs="unbounded"
		>
			<xs:element
				name="sqlParameter"
				type="sqlParameter" />
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="sqlParameter">
		<xs:attribute
			name="name"
			type="xs:NCName"
			use="required" />
		<xs:attribute
			name="isRequired"
			type="booleanType"
			use="optional" />
		<xs:attribute
			name="dataType"
			type="dt:declaredDataTypes"
			use="required" />
		<xs:attribute
			name="defaultValue"
			type="xs:string"
			use="optional" />
	</xs:complexType>

	<xs:complexType name="procedureParameter">
		<xs:attribute
			name="name"
			type="xs:NCName"
			use="required" />
		<xs:attribute
			name="dataType"
			type="dt:declaredDataTypes"
			use="optional" />
		<xs:attribute
			name="defaultValue"
			type="xs:string"
			use="optional" />
		<xs:attribute
			name="isRequired"
			type="booleanType"
			use="optional" />
		<xs:attribute
			name="inOutType"
			type="inOutType"
			use="required"
		>
			<xs:annotation>
				<xs:documentation>input, output or in-out</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="sqlObjectType"
			type="xs:NCName"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>If this parameter is a struct, or an array,
					specify the type name as defined in the procedure
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="recordName"
			type="xs:NCName"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>if this is an object/struct, specify the record
					that has represents the struct
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="isArray"
			type="booleanType"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>is this an array? You should also specify
					sqlArrayType
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="sqlArrayType"
			type="xs:NCName"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>type of the array as defined in the procedure
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>

	<xs:simpleType name="inOutType">
		<xs:restriction base="xs:NCName">
			<xs:enumeration value="input" />
			<xs:enumeration value="output" />
			<xs:enumeration value="inOut" />
		</xs:restriction>
	</xs:simpleType>



	<!-- ********************** service *********** -->

	<xs:element name="service">
		<xs:complexType>
			<xs:all>
				<xs:element
					name="inputData"
					type="inputData"
					minOccurs="0"
					maxOccurs="1"
				>
				</xs:element>
				<xs:element
					name="outputData"
					type="outputData"
					minOccurs="0"
					maxOccurs="1"
				>
				</xs:element>
				<xs:element
					name="actions"
					minOccurs="0"
					maxOccurs="1"
					type="actions" />
			</xs:all>
			<xs:attribute
				name="name"
				type="xs:NCName"
				use="required" />
			<xs:attribute
				name="moduleName"
				type="xs:string"
				use="optional" />
			<xs:attribute
				name="className"
				type="xs:string"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>fully qualified java class name that actually
						implements this service. No other attribute is relevant once you
						specify this.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="executeInBackground"
				type="xs:boolean"
				use="optional" />
			<xs:attribute
				name="description"
				type="xs:string"
				use="optional" />
			<xs:attribute
				name="dbAccessType"
				use="required"
			>
				<xs:simpleType>
					<xs:restriction base="xs:NCName">
						<xs:enumeration value="none" />
						<xs:enumeration value="readOnly" />
						<xs:enumeration value="readWrite" />
						<xs:enumeration value="autoCommit" />
						<xs:enumeration value="subService" />
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute
				name="referredServiceForInput"
				type="xs:string"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>
						If input is exactly the same as that of another
						service, use this feature. Note that the referred service MUST
						have input records, and can not refer to another service
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="referredServiceForOutput"
				type="xs:string"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>
						If output is exactly the same as that of another
						service, use this feature. Note that the referred service MUST
						have output records, and can not refer to another service
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="responseTextFieldName"
				type="xs:NCName"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>Special case where service has created a text to
						be sent to client as response. Specify the field name. Once this
						field name is specified, OutputData specification is ignored
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="requestTextFieldName"
				type="xs:NCName"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>Field to which request text is to be set to.
						InputData specification is ignored, and no data is extracted be
						sent to client as response. Specify the field name.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="schemaName"
				type="xs:NCName"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>Optional. Valid if allowServiceSpecificSchema is
						set to true in application.xml. default schema for the connection
						is set to this before executing the service.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="canBeCachedByFields"
				type="xs:NCName"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>can the response from this service be cached? If
						so what are the input fields that this response depends on?
						provide
						comma separated list of field names. Null (default) implies
						that
						this service can not be cashed.Empty string implies that the
						response does not depend on the input at all. If it is dependent
						on
						userId, then "_userId" must be the first field name. A cache
						manager can keep the response from this service and re-use it so
						long as the input values for these fields are same.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:complexType name="inputData">
		<xs:sequence
			minOccurs="1"
			maxOccurs="2"
		>
			<xs:element
				name="inputFields"
				type="inputFields"
				minOccurs="0"
				maxOccurs="1" />
			<xs:element
				name="inputRecords"
				type="inputRecords"
				minOccurs="0"
				maxOccurs="1" />
		</xs:sequence>
		<xs:attribute
			name="attachmentFields"
			type="xs:string"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>Comma separated list if fields that carry the key
					for attachment files. These MUST be included in the input fields.
					This is an additional info about those fields for us to manage the
					attachment
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="attachmentColumns"
			type="xs:string"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>Refer to attachmentFields. This is for columns in
					sheet. use sheetName.columnName to qualify.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="outputData">
		<xs:choice
			minOccurs="0"
			maxOccurs="unbounded"
		>
			<xs:element
				name="outputRecords"
				type="outputRecords"
				minOccurs="0"
				maxOccurs="1" />
		</xs:choice>
		<xs:attribute
			name="fieldNames"
			type="xs:string"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>Give comma separated names of fields to be sent to
					client. We will pick up values from context and send these values
					to client
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="dataSheets"
			type="xs:string"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>Give comma separated names of data sheets to be
					sent to client.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="attachmentFields"
			type="xs:string"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>Comma separated list if fields that carry the key
					for attachment files. These MUST be included in the input fields.
					This is an additional info about those fields for us to manage the
					attachment
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="attachmentColumns"
			type="xs:string"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>Refer to attachmentFields. This is for columns in
					sheet. use sheetName.columnName to qualify.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>

		<xs:attribute
			name="sessionFields"
			type="xs:string"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>Any session fields that you want to set or reset.
					Comma separated list of names. If you are writing your login
					service, this attribute is a MUST to set at least _userId to signal
					that the login process is successful.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>



	<xs:complexType name="inputRecords">
		<xs:sequence
			minOccurs="1"
			maxOccurs="unbounded"
		>
			<xs:element
				name="inputRecord"
				minOccurs="1"
				maxOccurs="unbounded"
			>
				<xs:complexType>
					<xs:attribute
						name="recordName"
						type="xs:string"
						use="required" />
					<xs:attribute
						name="fieldNames"
						type="xs:string"
						use="optional" />
					<xs:attribute
						name="minRows"
						type="xs:int"
						use="optional" />
					<xs:attribute
						name="maxRows"
						type="xs:int"
						use="optional" />
					<xs:attribute
						name="sheetName"
						type="xs:NCName"
						use="optional" />
					<xs:attribute
						name="extractIntoFields"
						type="booleanType"
						use="optional"
					>
						<xs:annotation>
							<xs:documentation>Use this option if client is sending one row in
								a sheet, but you want to extract the row into fields collection,
								rather than a data sheet.
							</xs:documentation>
						</xs:annotation>
					</xs:attribute>

					<xs:attribute
						name="description"
						type="xs:string"
						use="optional" />
					<xs:attribute
						name="purpose"
						use="optional"
					>
						<xs:simpleType>
							<xs:restriction base="xs:NCName">
								<xs:enumeration value="read" />
								<xs:enumeration value="filter" />
								<xs:enumeration value="subset" />
								<xs:enumeration value="save" />
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>


	<xs:complexType name="inputFields">
		<xs:sequence
			minOccurs="0"
			maxOccurs="1"
		>
			<xs:element
				name="inputField"
				minOccurs="1"
				maxOccurs="unbounded"
			>
				<xs:complexType>
					<xs:attribute
						name="name"
						type="xs:NCName"
						use="required" />
					<xs:attribute
						name="dataType"
						type="dt:declaredDataTypes"
						use="required" />
					<xs:attribute
						name="isRequired"
						type="booleanType"
						use="optional" />
					<xs:attribute
						name="defaultValue"
						type="xs:string"
						use="optional" />
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>

	<xs:complexType name="outputRecords">
		<xs:sequence
			minOccurs="1"
			maxOccurs="unbounded"
		>
			<xs:element
				name="outputRecord"
				minOccurs="1"
				maxOccurs="unbounded"
			>

				<xs:complexType>
					<xs:attribute
						name="recordName"
						type="xs:string"
						use="optional"
					>
						<xs:annotation>
							<xs:documentation>Use record name as a short-cut to specifying
								all the fields. Note that we do not use validate output
								parameters. We use only the names to pick values from output,
								and send to client
							</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attribute
						name="sheetName"
						type="xs:NCName"
						use="optional"
					>
						<xs:annotation>
							<xs:documentation>Name of the sheet to be sent to client. We send
								all columns as they are.
							</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attribute
						name="parentSheetName"
						type="xs:string"
						use="optional"
					>
						<xs:annotation>
							<xs:documentation>Sheet name to which this sheet should be
								embedded as child rows. You must specify the two link column
								attributes for this to work
							</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attribute
						name="linkColumnInThisSheet"
						type="xs:string"
						use="optional"
					>
						<xs:annotation>
							<xs:documentation>Required if parentSheet is specified. Column
								name in this sheet whose value is treated as parentKey to attach
								this row its parent row.
							</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attribute
						name="linkColumnInParentSheet"
						type="xs:string"
						use="optional"
					>
						<xs:annotation>
							<xs:documentation>Required if parentSheetName is specified.
								Column in parent sheet that has the primary key to parent sheet,
								which is used to match with parentKey in child sheet for
								embedding.
							</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:complexType>

			</xs:element>
		</xs:sequence>
	</xs:complexType>

	<xs:complexType name="actions">
		<xs:choice
			minOccurs="1"
			maxOccurs="unbounded"
		>
			<xs:element
				name="addColumn"
				type="addColumn"
				minOccurs="0"
				maxOccurs="unbounded" />
			<xs:element
				name="addMessage"
				type="addMessage"
				minOccurs="0"
				maxOccurs="unbounded" />
			<xs:element
				name="complexLogic"
				type="logic"
				minOccurs="0"
				maxOccurs="unbounded" />
			<xs:element
				name="copyRows"
				type="copyRows"
				minOccurs="0"
				maxOccurs="unbounded" />
			<xs:element
				name="copyUserId"
				type="copyUserId"
				minOccurs="0"
				maxOccurs="unbounded" />
			<xs:element
				name="createSheet"
				type="createSheet"
				minOccurs="0"
				maxOccurs="unbounded" />
			<xs:element
				name="executeSp"
				type="executeSp"
				minOccurs="0"
				maxOccurs="unbounded" />
			<xs:element
				name="executeSql"
				type="executeSql"
				minOccurs="0"
				maxOccurs="unbounded" />
			<xs:element
				name="filter"
				type="filter"
				minOccurs="0"
				maxOccurs="unbounded" />
			<xs:element
				name="jumpTo"
				type="jumpTo"
				minOccurs="0"
				maxOccurs="unbounded" />
			<xs:element
				name="httpClient"
				type="httpClient"
				minOccurs="0"
				maxOccurs="unbounded" />
			<xs:element
				name="keyValueList"
				type="keyValueList"
				minOccurs="0"
				maxOccurs="unbounded" />
			<xs:element
				name="log"
				type="log"
				minOccurs="0"
				maxOccurs="unbounded" />
			<xs:element
				name="logic"
				type="logic"
				minOccurs="0"
				maxOccurs="unbounded" />
			<xs:element
				name="loop"
				type="loop"
				minOccurs="0"
				maxOccurs="unbounded" />
			<xs:element
				name="read"
				type="read"
				minOccurs="0"
				maxOccurs="unbounded" />
			<xs:element
				name="readChildren"
				type="readChildren"
				minOccurs="0"
				maxOccurs="unbounded" />
			<xs:element
				name="readWithSql"
				type="readWithSql"
				minOccurs="0"
				maxOccurs="unbounded" />
			<xs:element
				name="removeValue"
				type="removeValue"
				minOccurs="0"
				maxOccurs="unbounded" />
			<xs:element
				name="renameSheet"
				type="renameSheet"
				minOccurs="0"
				maxOccurs="unbounded" />
			<xs:element
				name="replaceAttachment"
				type="replaceAttachment"
				minOccurs="0"
				maxOccurs="unbounded" />
			<xs:element
				name="rowExists"
				type="rowExists"
				minOccurs="0"
				maxOccurs="unbounded" />
			<xs:element
				name="save"
				type="save"
				minOccurs="0"
				maxOccurs="unbounded" />
			<xs:element
				name="setValue"
				type="setValue"
				minOccurs="0"
				maxOccurs="unbounded" />
			<xs:element
				name="subService"
				type="subService"
				minOccurs="0"
				maxOccurs="unbounded" />
			<xs:element
				name="suggest"
				type="suggest"
				minOccurs="0"
				maxOccurs="unbounded" />
		</xs:choice>
	</xs:complexType>

	<xs:attributeGroup name="actionAttributes">
		<xs:attribute
			name="actionName"
			type="xs:string"
			use="optional" />
		<xs:attribute
			name="executeOnCondition"
			type="xs:string"
			use="optional" />
		<xs:attribute
			name="executeIfRowsInSheet"
			type="xs:string"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation> act on this if a data sheet exists in context,
					and it has at least one row
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="executeIfNoRowsInSheet"
			type="xs:string"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation> act on this if context does not have this sheet,
					or that sheet has no rows
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="description"
			type="xs:string"
			use="optional" />
	</xs:attributeGroup>

	<xs:attributeGroup name="dbActionAttributes">
		<xs:attributeGroup ref="actionAttributes" />
		<xs:attribute
			name="successMessageName"
			type="xs:string"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>Message to be flashed if this action
					extracts/affected one or more records. This message is to be
					defined as a message component
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="successMessageParameters"
			type="xs:string"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>Message to be flashed if this action
					extracts/affected one or more records. This message is to be
					defined as a message component
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="failureMessageName"
			type="xs:string"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>In case the message is parameterized, provide
					comma
					separated list of values. Value starting with $ is assumed to
					be a
					fieldName to get value at run time.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="failureMessageParameters"
			type="xs:string"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>In case the message is parameterized, provide
					comma
					separated list of values. Value starting with $ is assumed to
					be a
					fieldName to get value at run time.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="stopIfMessageTypeIsError"
			type="booleanType"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>Message to be flashed if this action
					extracts/affected one or more records. This message is to be
					defined as a message component
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>

	<xs:complexType name="addColumn">
		<xs:attributeGroup ref="actionAttributes" />
		<xs:attribute
			name="sheetName"
			type="xs:string"
			use="required"
		>
			<xs:annotation>
				<xs:documentation>Sheet to which a column needs to be added
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="columnName"
			type="xs:NCName"
			use="required"
		>
			<xs:annotation>
				<xs:documentation>Name of column to be added</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="columnValueType"
			type="valueType"
			use="required"
		>
			<xs:annotation>
				<xs:documentation>What type of value is this column going to
					contain.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="columnValue"
			type="xs:string"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>
					if the value is going to be the same for all rows,
					use this feature. Just specify the value if it is constant. In case
					it is a field in the context, specify $fieldName.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="columnValueExpression"
			type="xs:string"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>Expression that is evaluated for each row to
					assign value of the column for that row. Optional if you are going
					to assign value later.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="addMessage">
		<xs:attributeGroup ref="actionAttributes" />
		<xs:attribute
			name="messageName"
			type="xs:string"
			use="required"
		>
			<xs:annotation>
				<xs:documentation>qualified message name from defined messages.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="parameters"
			type="xs:string"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>comma separated list of values, if message is
					parameterised. value starting with $, like $customerName implies
					that the value is to be picked up at run time from that field.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="stopIfMessageTypeIsError"
			type="booleanType"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>if the message type of the message is ERROR,
					should we stop/end this service. Normally you end the service, but
					in case you are accumulating validation errors, you may want to
					continue.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="copyRows">
		<xs:attributeGroup ref="actionAttributes" />
		<xs:attribute
			name="fromSheetName"
			type="xs:string"
			use="required"
		>
			<xs:annotation>
				<xs:documentation>Sheet from which rows are copied. If this sheet is
					not found, or has zero rows, no error is generated, but 0 is the
					result
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="toSheetName"
			type="xs:string"
			use="required"
		>
			<xs:annotation>
				<xs:documentation>Sheet to which rows are copied to. If this is not
					found, we copy entire fromSheet as toSheet, failing which we set 0
					as result, but no error.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="copyUserId">
		<xs:attributeGroup ref="actionAttributes" />
		<xs:attribute
			name="fieldName"
			type="xs:string"
			use="required"
		>
			<xs:annotation>
				<xs:documentation>Field to which userId is to be copied to
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="createSheet">
		<xs:attributeGroup ref="actionAttributes" />
		<xs:attribute
			name="sheetName"
			type="xs:string"
			use="required"
		>
			<xs:annotation>
				<xs:documentation>Name by which sheet is to be added to
					serviceContext. Once added, this sheet is available for subsequent
					actions, as well as for output
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="data"
			type="xs:string"
			use="required"
		>
			<xs:annotation>
				<xs:documentation>
					Of the form
					header1,header2...;val11,val12,val13...;val21,val22,val23.... rows
					are separated by semicolon(;)and cells are separated by comma(,)
					first row is header. refer to fieldValue attribute of setValue for
					syntax of cells. Each cell can be either a field name ($fieldNAme)
					or constant.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="fieldValue"
			type="xs:string"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>
					use either a constant, or a $fieldName as value
					ofthe field. If you use this, you should not specify expression.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="executeSp">
		<xs:attributeGroup ref="dbActionAttributes" />
		<xs:attribute
			name="procedureName"
			type="xs:string"
			use="required"
		>
			<xs:annotation>
				<xs:documentation>qualified name of .xml component you have saved
					under sp folder. This is NOT the name of stored procedure in your
					DB
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="sheetNameForInputParameters"
			type="xs:NCName"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>If your sp has in parameters, by default we pick
					them up from name-value pairs. But if you have designed to have
					them in a sheet, this is the name of that sheet.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="sheetNameForOutputParameters"
			type="xs:NCName"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>If your sp has out parameters, by default we
					extract them to name-value pairs. But if you have designed to have
					them in a sheet, this is the name of that sheet.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="outputSheetNames"
			type="xs:string"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>If your SP extracts one or more result set (but
					not return them as parameters), by default we extract them to sheet
					names based on record. You may change the names with this
					attribute. Use comma separated list if there are 2 or more sheets
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="executeSql">
		<xs:attributeGroup ref="dbActionAttributes" />
		<xs:attribute
			name="sqlName"
			type="xs:string"
			use="required" />
		<xs:attribute
			name="inputSheetName"
			type="xs:NCName"
			use="optional" />
		<xs:attribute
			name="treatSqlErrorAsNoResult"
			type="booleanType"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>If constraints are defined in database, you may
					want to use that to try to save, failing which you may want to
					treat it as validation error, rather than a SQL Exception.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>

	</xs:complexType>

	<xs:complexType name="filter">
		<xs:sequence>
			<xs:element
				name="childRecords"
				type="relatedRecords"
				minOccurs="0"
				maxOccurs="1" />
		</xs:sequence>
		<xs:attributeGroup ref="dbActionAttributes" />
		<xs:attribute
			name="filterRecordName"
			type="xs:string"
			use="required" />
		<xs:attribute
			name="outputRecordName"
			type="xs:string"
			use="optional" />
		<xs:attribute
			name="inputSheetName"
			type="xs:string"
			use="optional" />
		<xs:attribute
			name="outputSheetName"
			type="xs:string"
			use="optional" />
		<xs:attribute
			name="cascadeFilterForChildren"
			type="booleanType"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>By default, only the first level children are read
					along with the parent. Do you want that action to cascade down to
					subsequent generations as well? That is, if the childRecord has
					children, read them as well, and so on.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="httpClient">
		<xs:all>
			<xs:element
				minOccurs="0"
				maxOccurs="1"
				name="requestData"
				type="outputData"
			>
				<xs:annotation>
					<xs:documentation>If data needs to be formatted as a json from set
						of data fields/sheets in the service context, use this option. If
						the data is non-json, or a simple value of a field, use
						requestFieldName attribute instead.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element
				minOccurs="0"
				maxOccurs="1"
				name="responseData"
				type="inputData"
			>
				<xs:annotation>
					<xs:documentation>If data needs to be formatted as a json from set
						of data fields/sheets in the service context, use this option. If
						the data is non-json, or a simple value of a field, use
						requestFieldName attribute instead.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:all>
		<xs:attributeGroup ref="actionAttributes" />
		<xs:attribute
			name="urlString"
			type="xs:string"
			use="required"
		>
			<xs:annotation>
				<xs:documentation>provide full url. In case the url has parts that
					are known at run time, use ${fieldName}. For example
					http://.....${orderNo}...${customerId}... Values are substituted at
					run time. If field has no value in the context, we use empty string
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="contentType"
			type="xs:string"
			use="required"
		>
			<xs:annotation>
				<xs:documentation>example application/json or application/xml or
					text/html. We assume that the content type is same for both request
					and response, in case we send request data as well.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="requestFieldName"
			type="xs:NCName"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>if request data is to be sent, this is the field
					that will have the data at run time in service context. Ensure that
					the value is as per the requirements for the request.For example it
					could be a valid json, xml or form data, as required by the
					service.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="responseFieldName"
			type="xs:NCName"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>response from service is assigned as value of this
					field in the service context. Not valid if you have specified
					responseData provide full url. In case the url has parts that
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="proxy"
			type="xs:string"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>in case the service request has to go thru a
					proxy.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="proxyUserName"
			type="xs:string"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>For proxy credential. use $fieldName in case the
					value is known at run time. (not ${fieldName})
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="proxyPassword"
			type="xs:string"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>For proxy credential. use $fieldName in case the
					value is known at run time. (not ${fieldName})
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="proxyPort"
			type="xs:int"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>Required if proxy is to be used
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="jumpTo">
		<xs:attributeGroup ref="actionAttributes" />
		<xs:attribute
			name="toAction"
			type="xs:string"
			use="required" />
	</xs:complexType>

	<xs:complexType name="log">
		<xs:attributeGroup ref="actionAttributes" />
		<xs:attribute
			name="names"
			type="xs:string"
			use="required"
		>
			<xs:annotation>
				<xs:documentation>Comma separated list of names of fields and sheets
					whose values are to be logged at this stage.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="keyValueList">
		<xs:attributeGroup ref="dbActionAttributes" />
		<xs:attribute
			name="recordName"
			type="xs:string"
			use="required" />
		<xs:attribute
			name="outputSheetName"
			type="xs:NCName"
			use="optional" />
	</xs:complexType>

	<xs:complexType name="logic">
		<xs:attributeGroup ref="actionAttributes" />
		<xs:attribute
			name="className"
			type="xs:string"
			use="required" />
	</xs:complexType>

	<xs:complexType name="loop">
		<xs:sequence
			minOccurs="1"
			maxOccurs="1"
		>
			<xs:element
				name="actions"
				type="actions"
				minOccurs="1"
				maxOccurs="1" />
		</xs:sequence>
		<xs:attributeGroup ref="actionAttributes" />
		<xs:attribute
			name="dataSheetName"
			type="xs:string"
			use="required" />
	</xs:complexType>

	<xs:complexType name="read">
		<xs:sequence>
			<xs:element
				name="childRecords"
				type="relatedRecords"
				minOccurs="0"
				maxOccurs="1" />
		</xs:sequence>
		<xs:attributeGroup ref="dbActionAttributes" />
		<xs:attribute
			name="recordName"
			type="xs:string"
			use="required" />
		<xs:attribute
			name="inputSheetName"
			type="xs:NCName"
			use="optional" />
		<xs:attribute
			name="outputSheetName"
			type="xs:NCName"
			use="optional" />
		<xs:attribute
			name="cascadeFilterForChildren"
			type="booleanType"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>By default, only the first level children are read
					along with the parent. Do you want that action to cascade down to
					subsequent generations as well? That is, if the childRecord has
					children, read them as well, and so on.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="readChildren">
		<xs:attributeGroup ref="dbActionAttributes" />
		<xs:attribute
			name="recordName"
			type="xs:string"
			use="required" />
		<xs:attribute
			name="outputSheetName"
			type="xs:NCName"
			use="optional" />
		<xs:attribute
			name="parentKeyFieldName"
			type="xs:NCName"
			use="optional" />
	</xs:complexType>

	<xs:complexType name="readWithSql">
		<xs:sequence>
			<xs:element
				name="childRecords"
				type="relatedRecords"
				minOccurs="0"
				maxOccurs="1" />
		</xs:sequence>
		<xs:attributeGroup ref="dbActionAttributes" />
		<xs:attribute
			name="sqlName"
			type="xs:string"
			use="required" />
		<xs:attribute
			name="inputSheetName"
			type="xs:NCName"
			use="optional" />
		<xs:attribute
			name="outputSheetName"
			type="xs:NCName"
			use="optional" />
		<xs:attribute
			name="cascadeFilterForChildren"
			type="booleanType"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>By default, only the first level children are read
					along with the parent. Do you want that action to cascade down to
					subsequent generations as well? That is, if the childRecord has
					children, read them as well, and so on.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="renameSheet">
		<xs:attributeGroup ref="actionAttributes" />
		<xs:attribute
			name="sheetName"
			type="xs:string"
			use="required" />
		<xs:attribute
			name="newSheetName"
			type="xs:string"
			use="required" />
	</xs:complexType>

	<xs:complexType name="replaceAttachment">
		<xs:attributeGroup ref="dbActionAttributes" />
		<xs:attribute
			name="recordName"
			type="xs:string"
			use="required"
		>
			<xs:annotation>
				<xs:documentation>Record us used to get the rdbms table and the key
					field details. This record must contain the attachment field that
					we are replacing. Other fields may be there, but we ignore them.
					With this behavior, you may reuse a record define for regular save
					operation.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="attachmentFieldName"
			type="xs:string"
			use="required" />
	</xs:complexType>

	<xs:complexType name="rowExists">
		<xs:attributeGroup ref="actionAttributes" />
		<xs:attribute
			name="fieldName"
			type="xs:string"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>if you want to use a key field name different from
					the one defined in the record.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="recordName"
			type="xs:string"
			use="required"
		>
			<xs:annotation>
				<xs:documentation>record to check the row</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="save">
		<xs:sequence>
			<xs:element
				name="childRecords"
				type="relatedRecords"
				minOccurs="0"
				maxOccurs="1" />
		</xs:sequence>
		<xs:attributeGroup ref="dbActionAttributes" />
		<xs:attribute
			name="recordName"
			type="xs:string"
			use="required" />
		<xs:attribute
			name="inputSheetName"
			type="xs:string"
			use="optional" />
		<xs:attribute
			name="treatSqlErrorAsNoResult"
			type="booleanType"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>If constraints are defined in database, you may
					want to use that to try to save, failing which you may want to
					treat it as validation error, rather than a SQL Exception.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="saveAction"
			use="required"
		>
			<xs:annotation>
				<xs:documentation>auto means we will figure out based on presence of
					value of primary key
				</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:NCName">
					<xs:enumeration value="save" />
					<xs:enumeration value="add" />
					<xs:enumeration value="modify" />
					<xs:enumeration value="delete" />
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="setValue">
		<xs:all
			minOccurs="0"
			maxOccurs="1"
		>
			<xs:element name="expression">
				<xs:annotation>
					<xs:documentation>
						Use CDATA section if your expression is complex,
						and is confusing with xml escaping for quotes etc..
					</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:all>
		<xs:attributeGroup ref="actionAttributes" />
		<xs:attribute
			name="fieldName"
			type="xs:string"
			use="required" />
		<xs:attribute
			name="expression"
			type="xs:string"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>
					Note that you have to xml escape double quote and less-than,
					greater-than etc.. If this is confusing,use expression element
					instead with CDATA section.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="fieldValue"
			type="xs:string"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>
					use either a constant, or a $fieldName as value of
					the field. If you use this, you should not specify expression.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>


	<xs:complexType name="removeValue">
		<xs:all
			minOccurs="0"
			maxOccurs="1"
		>
		</xs:all>
		<xs:attributeGroup ref="actionAttributes" />
		<xs:attribute
			name="fieldName"
			type="xs:string"
			use="required" />
	</xs:complexType>



	<xs:complexType name="subService">
		<xs:attributeGroup ref="actionAttributes" />
		<xs:attribute
			name="serviceName"
			type="xs:string"
			use="required"
		>
			<xs:annotation>
				<xs:documentation>Fully qualified service name</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="suggest">
		<xs:attributeGroup ref="actionAttributes" />
		<xs:attribute
			name="recordName"
			type="xs:string"
			use="required"
		>
			<xs:annotation>
				<xs:documentation>Fully qualified service name</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="fieldToMatch"
			type="xs:string"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>Field to filter on. defaults to what is specified
					in record. default is to match anywhere. If you want to match
					starting only, then a special field named _matchStarting can be set
					to true.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="outputSheetName"
			type="xs:string"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>Name of the output data sheet. If not specified,
					it defaults to the name as specified in record.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>


	<xs:complexType name="restClient">
		<xs:attributeGroup ref="actionAttributes" />

		<xs:attribute
			name="restMethod"
			use="required"
		>
			<xs:annotation>
				<xs:documentation>
					Field to filter on. defaults to what is specified
					in record. default is to match anywhere. If you want to match
					starting only, then a special field named _matchStarting can be set
					to true.
				</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="GET"></xs:enumeration>

				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute
			name="urlString"
			type="xs:string"
			use="required"
		>
		</xs:attribute>
		<xs:attribute
			name="contentType"
			use="required"
		>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="application/json"></xs:enumeration>
					<xs:enumeration value="application/xml"></xs:enumeration>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute
			name="proxy"
			type="xs:string"
			use="optional"
		></xs:attribute>
		<xs:attribute
			name="proxyport"
			type="xs:int"
		></xs:attribute>
		<xs:attribute
			name="proxyUserName"
			type="xs:string"
			use="optional"
		>
		</xs:attribute>
		<xs:attribute
			name="proxyPassword"
			type="xs:string"
			use="optional"
		>
		</xs:attribute>
		<xs:attribute
			name="outputFieldName"
			type="xs:string"
			use="required"
		>
			<xs:annotation>
				<xs:documentation>
					Name of the output data sheet. If not specified,
					it defaults to the name as specified in record.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="outputFieldValue"
			type="xs:string"
		></xs:attribute>
	</xs:complexType>

	<xs:simpleType name="valueType">
		<xs:restriction base="xs:NCName">
			<xs:enumeration value="text" />
			<xs:enumeration value="boolean" />
			<xs:enumeration value="integer" />
			<xs:enumeration value="decimal" />
			<xs:enumeration value="date" />
		</xs:restriction>
	</xs:simpleType>

	<xs:complexType name="relatedRecords">
		<xs:annotation>
			<xs:documentation>Typically child tables that are read/saved along
				with parent
			</xs:documentation>
		</xs:annotation>
		<xs:sequence
			minOccurs="1"
			maxOccurs="unbounded"
		>
			<xs:element name="relatedRecord">
				<xs:complexType>
					<xs:attribute
						name="recordName"
						type="xs:string"
						use="required"
					>
						<xs:annotation>
							<xs:documentation>related record name. Fully qualified please.
							</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attribute
						name="sheetName"
						type="xs:string"
						use="required"
					>
						<xs:annotation>
							<xs:documentation>sheet name that has data for this record
							</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attribute
						name="replaceRows"
						type="booleanType"
						use="optional"
					>
						<xs:annotation>
							<xs:documentation>
								if the child rows are not referred any where
								else, it is simpler at times to just delete all existing rows,
								and insert new ones. Use this flag for such an operation. Note
								that save action at the rows are ignored, and all rows are
								inserted
							</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>

	<xs:simpleType name="messageType">
		<xs:restriction base="xs:NCName">
			<xs:enumeration value="info" />
			<xs:enumeration value="warning" />
			<xs:enumeration value="error" />
			<xs:enumeration value="success" />
		</xs:restriction>
	</xs:simpleType>

	<xs:element name="parameter">
		<xs:complexType>
			<xs:attribute
				name="name"
				type="xs:NCName"
				use="required" />
			<xs:attribute
				name="valueType"
				type="valueType"
				use="required" />
		</xs:complexType>
	</xs:element>

	<xs:element
		name="functions"
		type="nameValuePairs"
	>
		<xs:annotation>
			<xs:documentation>define functions by mapping name to class
			</xs:documentation>
		</xs:annotation>
	</xs:element>

	<xs:complexType name="nameValuePairs">
		<xs:sequence
			minOccurs="1"
			maxOccurs="1"
		>
			<xs:element name="components">
				<xs:complexType>
					<xs:sequence
						minOccurs="1"
						maxOccurs="unbounded"
					>
						<xs:element name="entry">
							<xs:complexType>
								<xs:attribute
									name="name"
									type="xs:string"
									use="required"
								>
									<xs:annotation>
										<xs:documentation>Simple name. This service will be referred
											as fileName.name
										</xs:documentation>
									</xs:annotation>
								</xs:attribute>
								<xs:attribute
									name="description"
									type="xs:string"
									use="optional"
								>
									<xs:annotation>
										<xs:documentation>Of course, good description, but not story.
										</xs:documentation>
									</xs:annotation>
								</xs:attribute>
								<xs:attribute
									name="className"
									type="xs:string"
									use="required"
								>
									<xs:annotation>
										<xs:documentation>fully qualified class name like
											com.example.a.service.MyService
										</xs:documentation>
									</xs:annotation>
								</xs:attribute>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>

	<!-- *********************** custom services ************************************** -->
	<xs:element
		name="services"
		type="nameValuePairs"
	>

		<xs:annotation>
			<xs:documentation>Define services that are implemented using java
				class
			</xs:documentation>
		</xs:annotation>
	</xs:element>

	<xs:element name="application">
		<xs:complexType>
			<xs:sequence>
				<xs:element
					name="schemaDetails"
					minOccurs="0"
					maxOccurs="1"
				>
					<xs:annotation>
						<xs:documentation>If your application used more than one schemas,
							then you need to provide details for non-default schema
						</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:sequence minOccurs="1">
							<xs:element
								name="schemaDetail"
								minOccurs="1"
								maxOccurs="unbounded"
							>
								<xs:complexType>
									<xs:attribute
										name="schemaName"
										type="xs:string"
										use="required" />
									<xs:attribute
										name="dataSourceName"
										type="xs:string"
										use="optional" />
									<xs:attribute
										name="connectionString"
										type="xs:string"
										use="optional" />
								</xs:complexType>
							</xs:element>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
			<xs:attribute
				name="applicationId"
				type="xs:NCName"
				use="required"
			>
				<xs:annotation>
					<xs:documentation>This must be UNIQUE within a corporate, so that
						we can use it as identity for inter-application communication
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="cacheComponents"
				type="booleanType"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>During development, we prefer not to cache
						components, so that any change to them is immediately reflected in
						the application. This reduces the build requirements.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="sendTraceToClient"
				type="booleanType"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>Should the trace be sent to client? True during
						development to help in debugging.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="dbVendor"
				use="optional"
			>
				<xs:simpleType>
					<xs:annotation>
						<xs:documentation>vendor specific specific syntax used ONLy when
							ansi syntax is not available for the specified vendor
						</xs:documentation>
					</xs:annotation>
					<xs:restriction base="xs:string">
						<xs:enumeration value="mysql" />
						<xs:enumeration value="postgre" />
						<xs:enumeration value="oracle" />
						<xs:enumeration value="mssql" />
						<xs:enumeration value="h2" />
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute
				name="connectionString"
				type="xs:string"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>complete string including credentials
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="dbDriverClassName"
				type="xs:string"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation></xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="dataSourceName"
				type="xs:string"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>Preferred way to establish connection.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="loginServiceName"
				type="xs:string"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>login service will be called with loginId and
						securityToken. If you use SSO, security token would be the
						authenticated ssoId, otherwise it would be the password entered by
						user. This service MUST set _userId as sessionField using
						sessionFields="" attribute of outputData tag. All these fields
						will be used as global data, and will be made available to all
						services.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="logoutServiceName"
				type="xs:string"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>If your application needs to do anything when
						user logs-out/times-out do you need to do anything? Specify the
						service name that is going to be called. userId as well all global
						fields are going to be available to your service. Also a boolean
						is supplied that indicates whether the user logged-out explicitly,
						or got timed-out
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="userIdIsNumber"
				type="xs:string"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>Simplity need to know the data type of userId
						(identify of the logged-in user that is generally saved in tables
						as modified-by-user). Default is text, which you can change to
						integral. Of course, we do not allow you to design it as any other
						type
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="autoLoginUserId"
				type="xs:string"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>During development/demo, login would be a
						nuisance. You may disable that, and use a default userId for all
						services. Ensure that this is a number in case your project uses
						numeric value as userId, as set in userIdIsNumber
						attribute.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="httpCacheManager"
				type="xs:string"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>Responses can be cached at http(web tier) as well
						as at service (app tier). specify the qualified class name for the
						http cache manager that implements HttpCacheManager interface.
						Services should indicate cacheability in response service data
						(refer to service.xml attributes)
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="serviceCacheManager"
				type="xs:string"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>Responses can be cached at http(web tier) as well
						as at service (app tier). specify the qualified class name for the
						service cache manager that implements ServiceCacheManager
						interface. Services should indicate cacheability in response
						service data (refer to service.xml attributes)
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="accessController"
				type="xs:string"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>refer to org.simplity.service.AccessController
						class.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="exceptionListener"
				type="xs:string"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>refer to org.simplity.service.ExceptionListener
						class. This feature allows you to wire exceptions to any corporate
						infrastructure to deal with exceptions
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="logSqls"
				type="booleanType"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>Should the server log the sqs that are being
						executed? This would be off in production for security reasons,
						but would be quite helpful during development
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="attachmentsFolderPath"
				type="xs:string"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>Simplity provides a simple way to store
						attachments in folder that is accessible to web tier as well as
						App tier. Use this attribute to set the folder.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="attachmentAssistant"
				type="xs:string"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>Way to interface with your own attachment
						management infrastructure. This plug-in handles storage and
						retrieval for all your services. Refer to
						org.simplity.AttachmentManager class
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="traceWrapper"
				type="xs:string"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>By default, service-log is wrapped in a simple
						xml element and the actual trace text is put inside a CDATA
						section. You may format it differently using your own wrapper that
						implements
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="loggingFramework"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>By default, service-log is emitted to console (System.out). If you use any of the standard logging framework, and you would like to service log to be diverted to your logger.
					</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:restriction base="xs:NCName">
						<xs:enumeration value="log4jClassic"><xs:annotation><xs:documentation>Old log4J uses log4j-1.2.17.jar</xs:documentation></xs:annotation></xs:enumeration>
						<xs:enumeration value="log4jV2"><xs:annotation><xs:documentation>Version 2.* of log4J. uses log4j-api-2.7.jar</xs:documentation></xs:annotation></xs:enumeration>
						<xs:enumeration value="commonsLogging"><xs:annotation><xs:documentation>Also known as JCL, uses commons-logging-1.2.jar</xs:documentation></xs:annotation></xs:enumeration>
						<xs:enumeration value="slf4j"><xs:annotation><xs:documentation>SLF4J adapter that you can bind to any other framework. For example slf4J-Simple or LogBack. slf4j-api-1.7.2.jar</xs:documentation></xs:annotation></xs:enumeration>
						<xs:enumeration value="juli"><xs:annotation><xs:documentation>Plain vanilla java.util.logging. Requires no jar file, but configuration is the key</xs:documentation></xs:annotation></xs:enumeration>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<!-- Test case. we systematically develop elements bottom-up for this.. -->

	<!-- testFieldAtts is common to inputField and outputField -->
	<xs:attributeGroup name="testFieldAtts">
		<xs:attribute
			name="fieldSelector"
			type="xs:string"
			use="required"
		>
			<xs:annotation>
				<xs:documentation>You may use pattern like order.lines.2.name to get
					name attribute from third element of lines-array of attribute order
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="fieldValue"
			type="xs:string"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>use $ as first character to specify a variable in
					the test context as value for this.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>

	<xs:complexType name="testFieldIn">
		<xs:attributeGroup ref="testFieldAtts" />
	</xs:complexType>

	<xs:complexType name="testFieldOut">
		<xs:attributeGroup ref="testFieldAtts" />
		<xs:attribute
			name="shouldBeAbsent"
			type="booleanType"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>if you are asserting that this field is absent in
					the output. fieldValue should not be specified.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="testFieldCtx">
		<xs:attribute
			name="fieldSelector"
			type="xs:string"
			use="required"
		>
			<xs:annotation>
				<xs:documentation>You may use pattern like order.lines.2.name to get
					name attribute from third element of lines-array of attribute order
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="nameInContext"
			type="xs:string"
			use="optional"
		>
			<xs:annotation>
				<xs:documentation>name of the context variable to set this to. This
					is the name used by subsequent services to refer to this value.
					Defaults to field selector
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="testFieldsIn">
		<xs:sequence>
			<xs:element
				name="inputField"
				type="testFieldIn"
				minOccurs="1"
				maxOccurs="unbounded"
			></xs:element>
		</xs:sequence>
	</xs:complexType>

	<xs:complexType name="testFieldsOut">
		<xs:sequence>
			<xs:element
				name="outputField"
				type="testFieldOut"
				minOccurs="1"
				maxOccurs="unbounded" />
		</xs:sequence>
	</xs:complexType>

	<xs:complexType name="testFieldsCtx">
		<xs:sequence>
			<xs:element
				name="contextField"
				type="testFieldCtx"
				minOccurs="1"
				maxOccurs="unbounded"
			></xs:element>
		</xs:sequence>
	</xs:complexType>

	<xs:complexType name="testItemIn">
		<xs:sequence>
			<xs:element
				minOccurs="1"
				maxOccurs="1"
				name="inputFields"
				type="testFieldsIn" />
		</xs:sequence>
		<xs:attribute
			name="itemSelector"
			type="xs:string"
			use="required"
		>
			<xs:annotation>
				<xs:documentation>item selector, for example order, or order.lines.2
					Ensure that the selector selects an item, and not a an array at run
					time. This item is the parent for all the fields in the fields
					collection. Their selector would be relative to this item
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="testItemOut">
		<xs:sequence>
			<xs:element
				minOccurs="1"
				maxOccurs="1"
				name="outputFields"
				type="testFieldsOut" />
		</xs:sequence>
		<xs:attribute
			name="itemSelector"
			type="xs:string"
			use="required"
		>
			<xs:annotation>
				<xs:documentation>item selector, for example order, or order.lines.2
					Ensure that the selector selects an item, and not a an array at run
					time. This item is the parent for all the fields in the fields
					collection. Their selector would be relative to this item
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="testListOut">
		<xs:attribute
			name="listSelector"
			type="xs:string"
			use="required"
		>
			<xs:annotation>
				<xs:documentation>list selector, for example order, or order.lines
					Ensure that the selector selects an array, and not a an object at
					run time.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute
			name="minRows"
			type="xs:int"
			use="optional" />
		<xs:attribute
			name="maxRows"
			type="xs:int"
			use="optional" />
	</xs:complexType>

	<xs:complexType name="testItemsIn">
		<xs:sequence>
			<xs:element
				minOccurs="1"
				maxOccurs="unbounded"
				name="inputItem"
				type="testItemIn" />
		</xs:sequence>
	</xs:complexType>

	<xs:complexType name="testItemsOut">
		<xs:sequence>
			<xs:element
				minOccurs="1"
				maxOccurs="unbounded"
				name="outputItem"
				type="testItemOut" />
		</xs:sequence>
	</xs:complexType>

	<xs:complexType name="testListsOut">
		<xs:sequence>
			<xs:element
				minOccurs="1"
				maxOccurs="unbounded"
				name="outputList"
				type="testListOut" />
		</xs:sequence>
	</xs:complexType>

	<xs:element name="testCase">
		<xs:complexType>
			<xs:all>
				<xs:element
					minOccurs="0"
					maxOccurs="1"
					name="inputJson"
					type="xs:string"
				>
					<xs:annotation>
						<xs:documentation>Use a CDATA section to specify a json. Since
							json is full of double quotes, it is quite ugly to specify it as
							attribute or content. This is the initial JSON. Other input
							specifications can alter or add to this
						</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element
					minOccurs="0"
					maxOccurs="1"
					name="outputJson"
					type="xs:string"
				>
					<xs:annotation>
						<xs:documentation>Use a CDATA section to specify a json. Once this
							is specified, no other specification about output makes sense.
						</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element
					minOccurs="0"
					maxOccurs="1"
					name="inputFields"
					type="testFieldsIn" />
				<xs:element
					minOccurs="0"
					maxOccurs="1"
					name="inputItems"
					type="testItemsIn" />
				<xs:element
					minOccurs="0"
					maxOccurs="1"
					name="outputFields"
					type="testFieldsOut" />
				<xs:element
					minOccurs="0"
					maxOccurs="1"
					name="outputLists"
					type="testListsOut" />
				<xs:element
					minOccurs="0"
					maxOccurs="1"
					name="outputItems"
					type="testItemsOut" />
				<xs:element
					minOccurs="0"
					maxOccurs="1"
					name="fieldsToBeAddedToContext"
					type="testFieldsCtx" />
			</xs:all>
			<xs:attribute
				name="testCaseName"
				type="xs:NCName"
				use="required"
			>
				<xs:annotation>
					<xs:documentation>Name should match the file within which this is
						defined.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="moduleName"
				type="xs:string"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>module name, if present should patch the folder
						structure within which this file is saved.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="description"
				type="xs:string"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>Unique name within a service for us to identify
						this test case
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="serviceName"
				type="xs:string"
				use="required"
			>
				<xs:annotation>
					<xs:documentation>Fully qualified name of service this test caseis
						meant for
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute
				name="testForFailure"
				type="booleanType"
				use="optional"
			>
				<xs:annotation>
					<xs:documentation>if this test case is to assert failure
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="testRun">
		<xs:complexType>
			<xs:sequence>
				<xs:element
					name="testCases"
					minOccurs="1"
					maxOccurs="1"
				>
					<xs:complexType>
						<xs:sequence>
							<xs:element
								ref="testCase"
								minOccurs="1"
								maxOccurs="unbounded" />
						</xs:sequence>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
			<xs:attribute
				name="testName"
				type="xs:string"
				use="required" />
			<xs:attribute
				name="moduleName"
				type="xs:string"
				use="optional" />
		</xs:complexType>
	</xs:element>
</xs:schema>
